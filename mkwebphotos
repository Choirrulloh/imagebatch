#!/usr/bin/env python

# From an image directory, make a web page.
# If there are images in the current directory, make a single web page;
# if there are subdirectories, make a hierarchy of them.

import os, sys
import subprocess
import shutil
from PIL import Image

# For importing standalone scripts as python modules:
import imp
imp.load_source("mkphplist",
                os.path.join(os.path.dirname(__file__), "mkphplist"))
import mkphplist

def is_image_file(f):
    '''Does this file have an extension, and it's not a thumbnail,
       i.e. it's not named *T.jpg?
    '''
    if f.endswith('.php'):
        return False
    lastdot = f.rfind('.')
    if lastdot < 0:
        return False
    if f[lastdot-1] == 'T':
        return False
    return True

def get_thumb_name(f):
    lastdot = f.rfind('.')
    if lastdot < 0:
        return None
    return f[:lastdot] + 'T' + f[lastdot:]

def read_tag_file(f):
    tags = {}
    fp = open(f)
    for line in fp:
        if not line:
            continue
        if line.startswith('#'):
            continue
        if line.startswith('category'):
            continue
        if line.startswith('tag '):
            line = line[4:]
        line = line.strip()
        if not line:
            continue
        parts = line.split(':')
        if len(parts) != 2:
            print "malformed tag file line:", line
            continue
        tag = parts[0].strip()
        tagged_files = parts[1].split(' ')
        if not tag:
            print "Null tag!", tag
            continue
        for t in tagged_files:
            t = t.strip()
            if not t:
                continue
            if tag in tags.keys():
                tags[tag].append(t)
            else:
                tags[tag] = [ t ]

    fp.close()
    return tags

# def header(title):
#     s = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

# <head>
# <title>%s</title>
# <link rel="stylesheet" type="text/css" href="/css/gallery.css" />
# <link rel="stylesheet" type="text/css" href="/css/gallerypic.css" />
# <!--[if lt IE 9]>
# <link rel="stylesheet" type="text/css" href="/css/gallery-ie.css" />
# <![endif]-->
# <!-- put any additional stylesheets here -->
# </head>

# <body>
# ''' % (title)
#     return s

def get_title_for_dir(d, default=None):
    title = os.path.split(os.path.basename(d))[1]
    if title.startswith('./'): title = title[2:]
    if title == '.':
        if default:
            title = default
        else:
            title = "Images"
    return title

def handle_dir(root, d, webpath=None):
    '''For a directory, make links to the subdirectories,
       using the first thumbnail if there are any at all.
    '''
    if webpath:
        newroot = os.path.normpath(os.path.join(webpath, root))
    else:
        newroot = root

    # Search for a thumbnail in the new root, not the old one.
    imgfile = None
    files = os.listdir(os.path.join(newroot, d))
    for f in files:
        lastdot = f.rfind('.')
        if lastdot < 0:
            continue
        if f[lastdot-1] != 'T':
            continue
        # It's a thumbnail file!
        imgfile = f
        img = Image.open(os.path.join(newroot, d, imgfile))
        break

    if imgfile:
        return '<li><a href="%s"><img src="%s/%s" width=%d height=%d alt="[%s]"><span class="caption">%s</span></a>\n' % \
            (d, d, imgfile, img.size[0], img.size[1], d, d)
    else:
        return '<li><a href="%s">%s</a>\n' % (d, d)

def handle_files(root, file_list, webpath=None, title=None):
    files = []
    dirs = []
    tags = None

    for f in file_list:
        if is_image_file(f):
            files.append(f)
        elif f == "Tags" or f == "Keywords":
            tags = read_tag_file(os.path.join(root, f))
        elif os.path.isdir(f):
            dirs.append(f)

    # But wait! If there's a tags file, and if we have a tag "web",
    # use the files in that list instead of our file list.
    # But we don't actually want to keep 'web' as a tag,
    # since we don't want it to show up in what mkphplist generates.
    if tags and 'web' in tags:
        webtags = tags['web']
        tags.pop('web')
        files = []
        for f in webtags:
            if os.path.exists(os.path.join(root, f)):
                files.append(f)
            else:
                print f, "is tagged 'web' but doesn't exist here"

    files.sort()
    print root, "Real files we'll work on:", files

    # Now copy those files to the web directory, if any.
    if webpath:
        newdir = os.path.normpath(os.path.join(webpath, root))
        if not os.path.exists(newdir):
            print "mkdir", newdir
            os.makedirs(newdir, 0755)
    else:
        newdir = root

    for f in files:
        if webpath:
            fpath = os.path.join(webpath, root, f)
            if not os.path.exists(fpath):
                print "Copy", os.path.join(root, f), fpath
                shutil.copy(os.path.join(root, f), fpath)

                # Only run exiftran, jhead and mogrify if we're copying.
                # Don't risk modifying original images in unreversible ways.
                # In particular, exiftran and jhead don't play well together.
                # Calling jhead on a file that exiftran and jhead have 
                # previously been called on produces the Nonfatal Error :
                # "More than 10 date fields!  This is nuts"
                print "Running exiftran, jhead, mogrify on", fpath
                subprocess.call(["exiftran", "-a", "-i", fpath])
                subprocess.call(["jhead", "-dt", "-norot", fpath])

                subprocess.call(["mogrify", "-quality", "83",
                                 "-scale", "600^>", fpath])

                os.chmod(fpath, 0644)
        else:
            fpath = os.path.join(root, f)
        fpath = os.path.normpath(fpath)

        thumb = get_thumb_name(fpath)
        if not thumb:
            # This shouldn't happen because it should have been weeded out.
            print f, "doesn't have an extension, skipping"
            continue

        if not os.path.exists(thumb):
            subprocess.call(["mkthumb", "-size", "200", fpath])

    if not title:
        title = get_title_for_dir(root)
    outstr = mkphplist.make_php_list(files, tags=tags, root=newdir, title=title)

    return outstr

if __name__ == '__main__':
    orig_path = '.'   # Some day make this a commandline argument
    web_dir = os.path.normpath(os.path.join(orig_path, 'web'))
    if not os.path.exists(web_dir):
        web_dir = '.'
        # XXX eventually might want to use some rule like,
        # mkdir web if the original dir has any subdirectories at all.

    toptitle = get_title_for_dir(os.getcwd())

    for root, dirs, files in os.walk(orig_path, topdown=False):
        # Don't copy the web directory
        if 'web' in dirs:
            dirs.remove('web')

        webpath = os.path.join(orig_path, web_dir)

        # Must handle files before directories, because handle_dir
        # will look for thumbnails which might not previously exist.
        title = get_title_for_dir(root, toptitle)
        if files:
            index = handle_files(root, files, webpath=webpath, title=title)
        else:
            index = ''

        if dirs:
            dirindex = '<ul class="thumbwrap">\n'
            for d in dirs:
                dirindex += handle_dir(root, d, webpath=webpath)
            dirindex += '</ul>'
        else:
            dirindex = ''

        # Write the directories first in the resulting file,
        # in the unlikely event there are both image files and subdirs.
        if dirindex or index:
            outfile = os.path.join(web_dir, root, 'index.php')
            print "Writing", outfile
            outfp = open(outfile, 'w')

            # outfp.write(header(title))
            if dirindex:
                outfp.write('<h1>%s</h1>' % title)
                outfp.write(dirindex)
            if index:
                # The PHP code to display files has its own title,
                # no need for an H1 here.
                outfp.write(index)
            outfp.write("\n</body></html>\n");
            outfp.close()
        else:
            print "Yikes, nothing to write!"

